{
  "code": "def calculate_stacking_properties(protein_atoms, protein_resid, na_atoms, na_resid):\n    import numpy as np\n    import scipy.spatial.distance\n    res_protein = protein_atoms[protein_atoms[\"resid\"]==protein_resid]\n    assert len(res_protein)\n    aa = res_protein[0][\"resname\"].decode().strip()\n    res_na = na_atoms[na_atoms[\"resid\"]==na_resid]\n    assert len(res_na)\n    nuc = res_na[0][\"resname\"].decode().strip()[-1] # one-letter\n    coor_res_protein = np.stack((res_protein[\"x\"], res_protein[\"y\"], res_protein[\"z\"])).T\n    coor_res_na = np.stack((res_na[\"x\"], res_na[\"y\"], res_na[\"z\"])).T\n\n    result = {}\n    dist = scipy.spatial.distance.cdist(coor_res_protein, coor_res_na)\n    result[\"closest_distance\"] = dist.min()\n\n    sidechains = {\n        \"PHE\": ['CG', 'CD1', 'CD2', 'CE1', 'CE2', 'CZ']\n    }\n    sidechain_mask = np.isin(res_protein[\"name\"], [name.encode() for name in sidechains[aa]])\n    bases = {\n        \"U\": ['C2', 'C4', 'C5', 'C6', 'N1', 'N3']\n    }\n    base_mask = np.isin(res_na[\"name\"], [name.encode() for name in bases[nuc]])\n    stacking_dist = dist[sidechain_mask][:,base_mask]\n    result[\"mean_stacking_dist\"] = stacking_dist.mean()\n    result[\"std_stacking_dist\"] = stacking_dist.std()\n\n    return result\n\ndef calculate_all_properties(protein_atoms, protein_resid, na_atoms, na_resid, x3dna_nucleotides):\n    stacking_properties = calculate_stacking_properties(protein_atoms, protein_resid, na_atoms, na_resid)\n    x3dna_nucl = [nucl for nucl in x3dna_nucleotides if nucl[\"nt_resnum\"] == na_resid]\n    assert len(x3dna_nucl) == 1\n    nucl_props = [\"gamma\", \"delta\", \"chi\"]\n    result = {}\n    for prop in nucl_props:\n        result[prop] = x3dna_nucl[0][prop]\n    result.update(stacking_properties)\n    return result",
  "language": "python",
  "type": "interpreted"
}
